<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数组划分 · 菜鸡Gustee的挣扎</title><meta name="description" content="数组划分 - Gustee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="菜鸡Gustee的挣扎"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/gustee" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">数组划分</h1><div class="post-info">Jun 2, 2019</div><div class="post-content"><h1 id="Partition的两种写法"><a href="#Partition的两种写法" class="headerlink" title="Partition的两种写法"></a>Partition的两种写法</h1><p>快排中核心的方法应该算是Partition函数了，它的作用就是将整个数组分成小于基准值的左边，和大于基准值的右边。</p>
<p>定义函数签名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span></span></span><br></pre></td></tr></table></figure></p>
<p>表示按照array[l]的值，把数组中索引从l到r的部分的元素小于array[l]放在其左边，大于array[l]放在其右边。<br>为了代码的可读性，定义交换数组中交换两个位置的元素的工具函数（虽然用python写起来也非常方便）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    array[l], array[r] = array[r], array[l]</span><br></pre></td></tr></table></figure></p>
<h3 id="最常见的写法"><a href="#最常见的写法" class="headerlink" title="最常见的写法:"></a>最常见的写法:</h3><p>用两个指针l和r，一个指向头，一个指向尾，将头指针移动到第一个不满足A[l]<k的数，将尾移动到第一个不满足a[r]>=k的数，交换两个数，然后重复往下查找不满足A[l]<k和a[r]>=k的数，继续交换。直到两指针相撞<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    key = array[l]</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">while</span> array[r] &gt; key <span class="keyword">and</span> r &gt; l:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> array[l] &lt; key <span class="keyword">and</span> r &gt; l:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        swap(array, l, r)</span><br><span class="line">    array[r] = key</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></k和a[r]></k的数，将尾移动到第一个不满足a[r]></p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>定义数组中(l-1, small]<code>[注：这里的(]表示左开右闭区间，即不包括l-1位置的元素，包括small位置的元素]</code>的区域为比key小的数，[big, r+1)<code>[注：左闭右开]</code>的区域为比key大的数，开始时两个区域中都没有数，将small初始化为l-1, big初始化为r+1。定义cur指针，指向当前遍历元素。当当前元素比key小时，将当前元素交换到small的右边，然后左边区域向右扩大一个，即small加1；当当前元素比key大时，将当前元素交换到big的左边，然后右边区域向左扩大一个，即big减一。函数最后返回划分完成之后第一个和最后一个等于key的元素的索引。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    key = array[l]</span><br><span class="line">    small = l - <span class="number">1</span></span><br><span class="line">    cur = l</span><br><span class="line">    big = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> cur != big:</span><br><span class="line">        <span class="keyword">if</span> array[cur] &lt; key:</span><br><span class="line">            small += <span class="number">1</span></span><br><span class="line">            swap(array, small, cur)</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> array[cur] &gt; key:</span><br><span class="line">            big -= <span class="number">1</span></span><br><span class="line">            swap(array, cur, big)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> small+<span class="number">1</span>, big<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在数组中找到第k大的元素<br><strong>思路：</strong> 每次把一个元素交换到正确的位置，同时把左边的都放上大的，右边都放上小的。这个算法每一次选取一个枢纽元，排序之后，查看枢纽元的位置。如果它的位置大于K，就说明，要求出前面一个子序列的第K大的元素。反之，如果小于K，就说明要求出在后面一个序列的第K - 前一个序列的长度个元素。<br><code>注意，与快排不同的是，这个算法的时间复杂度是O(N)，因为第一次交换，算法复杂度为O(N)，接下来的过程和快速排序不同，快速排序是要继续处理两边的数据，再合并，合并操作的算法复杂度是O(1)，于是总的算法复杂度是O(N*logN)（可以这么理解，每次交换用了N，一共logN次）。但是这里在确定枢纽元的相对位置（在K的左边或者右边）之后不用再对剩下的一半进行处理。也就是说第二次插入的算法复杂度不再是O(N)而是O(N/2)，这不还是一样吗？其实不一样，因为接下来的过程是1+1/2+1/4+........ &lt; 2，换句话说就是一共是O(2N)的算法复杂度也就是O(N)的算法复杂度。</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthLargestElement</span><span class="params">(k, nums)</span>:</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        ll, rr = partition(nums, l, r)</span><br><span class="line">        <span class="keyword">if</span> ll &lt;= k - <span class="number">1</span> &lt;= rr:</span><br><span class="line">            <span class="keyword">return</span> nums[ll]</span><br><span class="line">        <span class="keyword">elif</span> k &gt; rr:</span><br><span class="line">            l = rr + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = ll - <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/排序基础/" class="prev">上一篇</a><a href="/二叉树的遍历种种/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Gustee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>