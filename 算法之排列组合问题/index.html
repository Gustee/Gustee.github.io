<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 算法之排列组合问题 · 菜鸡Gustee的挣扎</title><meta name="description" content="算法之排列组合问题 - Gustee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="菜鸡Gustee的挣扎"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/gustee" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">算法之排列组合问题</h1><div class="post-info">Jun 2, 2019</div><div class="post-content"><h1 id="排列组合问题"><a href="#排列组合问题" class="headerlink" title="排列组合问题"></a>排列组合问题</h1><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><p><strong>排列：</strong> 一般地，从n个不同元素中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列(permutation)。特别地，当m=n时，这个排列被称作全排列(all permutation)。</p>
<h3 id="数组的全排列"><a href="#数组的全排列" class="headerlink" title="数组的全排列"></a>数组的全排列</h3><p>我们以<code>[1,2,3]</code>为例，首先我们从数组中选取数字<code>1</code>，然后和剩下的<code>[2,3]</code>组成的子排列构成全排列；然后从数组中选取数字<code>2</code>，然后和剩下的<code>[1,3]</code>组成的子排列构成全排列；最后从数组中选取数字<code>3</code>，然后和剩下的<code>[1,2]</code>组成的子排列构成全排列。详细的递归过程如下：<br><img src="/算法之排列组合问题/%E6%8E%92%E5%88%97.png" alt="排列"><br>代码实现细节：<br><code>index</code>表示向当前排列添加第<code>index</code>个元素。<br><code>p</code>表示当前的排列，其中拥有<code>index-1</code>个元素。<br>当<code>index</code>与数组长度相等时，说明一个全排列构造完成，保存该排列。否则，从<code>array</code>数组中选出一个未出现在<code>p</code>中的元素，加入当前排列，然后函数继续添加下一个位置的元素。<br><strong>注意：</strong> 使用当前元素构造排列完成保存后，要将该元素弹出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(array)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># p表示当前生成的排列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generatePermutation</span><span class="params">(array, index, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == len(array):</span><br><span class="line">            res.append(p.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">                p.append(i)</span><br><span class="line">                generatePermutation(array, index+<span class="number">1</span>, p)</span><br><span class="line">                p.pop()</span><br><span class="line">    generatePermutation(array, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3 id="普通排列"><a href="#普通排列" class="headerlink" title="普通排列"></a>普通排列</h3><p>从上文的全排列可以很容易的推广到普通的排列，只需要更改上面代码的排列构造完全的条件即可，<br><code>当index等于k时，当前的排列即构造完成，保存</code>，实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(array, k)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generatePermutation</span><span class="params">(array, index, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == k:</span><br><span class="line">            res.append(p.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">                p.append(i)</span><br><span class="line">                generatePermutation(array, index+<span class="number">1</span>, p)</span><br><span class="line">                p.pop()</span><br><span class="line">    generatePermutation(array, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3 id="重复排列"><a href="#重复排列" class="headerlink" title="重复排列"></a>重复排列</h3><p>重复排列(permutationwith repetiton)是一种特殊的排列。从n个不同元素中可重复地选取m个元素。按照一定的顺序排成一列，称作从n个元素中取m个元素的可重复排列。当且仅当所取的元素相同，且元素的排列顺序也相同，则两个排列相同。<code>只需将上面普通排列代码中判断数组元素是否在当前排列中的条件去掉即可</code>，实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(array, k)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generatePermutation</span><span class="params">(array, index, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == k:</span><br><span class="line">            res.append(p.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            p.append(i)</span><br><span class="line">            generatePermutation(array, index+<span class="number">1</span>, p)</span><br><span class="line">            p.pop()</span><br><span class="line">    generatePermutation(array, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p><strong>组合：</strong> 一般地，从n个不同的元素中，任取m（m≤n）个元素为一组，叫作从n个不同元素中取出m个元素的一个组合。</p>
<h3 id="数组的组合"><a href="#数组的组合" class="headerlink" title="数组的组合"></a>数组的组合</h3><p>我们以<code>[1,2,3，4]</code>中取<code>2</code>个数为例。在<code>[1,2,3,4]</code>中取<code>1</code>与排序相同，与排列不同的是，组合不考虑取出元素的顺序，所以在<code>[1,2,3,4]</code>中取<code>2</code>之后，只能在<code>[3,4]</code>中继续取值，因为之前已经计算出了所有包含<code>1</code>的组合。同理在<code>[1,2,3,4]</code>中取<code>3</code>之后，只能在<code>[4]</code>中取值。<br><img src="/算法之排列组合问题/%E7%BB%84%E5%90%88.png" alt="组合"><br><code>start</code>表示需要从数组的<code>start</code>位置开始搜索元素加入当前组合<code>c</code>中。<br><code>c</code>表示当前的组合。<br>当当前组合的长度等于k时，组合构造完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateCombinations</span><span class="params">(nums, start, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(c) == k:</span><br><span class="line">            res.append(c.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            c.append(nums[i])</span><br><span class="line">            generateCombinations(nums, i+<span class="number">1</span>, c)</span><br><span class="line">            c.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    generateCombinations(nums, <span class="number">0</span>, [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="LeedCode-Combination-Sum"><a href="#LeedCode-Combination-Sum" class="headerlink" title="LeedCode-Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">LeedCode-Combination Sum</a></h3><p><em>给出一个集合，其中所有的元素各不相同，以及一个数字T。寻找所有该集合中元素组合，使得组合中所有的元素和为T（集合中每一个元素可以使用多次）</em></p>
<ul>
<li>给定集合nums=[2,3,6,7], T=7`</li>
<li>返回[[7],[2,2,3]]</li>
</ul>
<hr>
<p><code>index</code>表示从集合的<code>index</code>的位置往后查找候选元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(candidates, index, target, cur_res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(cur_res.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> target &gt;= candidates[i]:</span><br><span class="line">                    cur_res.append(candidates[i])</span><br><span class="line">                    <span class="comment"># 由于每个元素可以使用多次，所以下次寻找候选元素还是从当前位置继续，而不是从下一个位置继续</span></span><br><span class="line">                    fun(candidates, i, target-candidates[i], cur_res)</span><br><span class="line">                    cur_res.pop()</span><br><span class="line"></span><br><span class="line">        fun(candidates, <span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-Subsets"><a href="#LeetCode-Subsets" class="headerlink" title="LeetCode-Subsets"></a><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">LeetCode-Subsets</a></h3><p><em>给出一个集合，其中所有的元素各不相同。求出该集合的所有字集。</em></p>
<ul>
<li>给定集合nums=[1,2,3]</li>
<li>返回[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]</li>
</ul>
<hr>
<p>第一种解法，n个元素的子集可以看做是$C_n^0, C_n^1,C_n^2,\cdots,C_n^k,\cdots,C_n^n$所有排列的集合，则在实现上与组合问题的区别即为不用判断当前当前的结果是否等于k，因为求子集需要k把0到n所有的数都要取一遍。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(nums, start, cur_res)</span>:</span></span><br><span class="line">            res.append(cur_res.copy())</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">                cur_res.append(nums[i])</span><br><span class="line">                fun(nums, i + <span class="number">1</span>, cur_res)</span><br><span class="line">                cur_res.pop()</span><br><span class="line"></span><br><span class="line">        fun(nums, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<hr>
<p>第二种解法，<code>对每个元素，有两种可能，加入当前组合和不加入组合</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(nums, index, cur_res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == len(nums):</span><br><span class="line">                res.append(cur_res.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 将当前元素不加入该组合</span></span><br><span class="line">            fun(nums, index+<span class="number">1</span>, cur_res)</span><br><span class="line">            <span class="comment"># 将当前元素加入该组合，</span></span><br><span class="line">            cur_res.append(nums[index])</span><br><span class="line">            fun(nums, index+<span class="number">1</span>, cur_res)</span><br><span class="line">            cur_res.pop()</span><br><span class="line"></span><br><span class="line">        fun(nums, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/排序基础/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Gustee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>