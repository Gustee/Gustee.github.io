<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 二分查找及其应用 · 菜鸡Gustee的挣扎</title><meta name="description" content="二分查找及其应用 - Gustee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="菜鸡Gustee的挣扎"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/gustee" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">二分查找及其应用</h1><div class="post-info">Jun 2, 2019</div><div class="post-content"><h2 id="普通的二分查找法"><a href="#普通的二分查找法" class="headerlink" title="普通的二分查找法"></a>普通的二分查找法</h2><p>给定一个排序的整数数组（升序）和一个要查找的整数<code>target</code>，用<code>O(logn)</code>的时间查找到target出现的下标（从0开始），如果target不存在于数组中，返回<code>-1</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, target)</span>:</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = len(arr)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="修改过的二分查找法"><a href="#修改过的二分查找法" class="headerlink" title="修改过的二分查找法"></a>修改过的二分查找法</h3><p>给定一个排序的整数数组（升序）和一个要查找的整数<code>target</code>，用<code>O(logn)</code>的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回<code>-1</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, target)</span>:</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = len(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid</span><br><span class="line">    <span class="keyword">if</span> arr[start] == target:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">elif</span> arr[end] == target:</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>若将条件改为查找target最后一次出现的下标（从0开始），那么程序将发生改变，循环中如果 arr[mid] = target, 则 start = mid; 且最后的边界判断改为先判断arr[end] == target; 其他不变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, target)</span>:</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = len(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> arr[end] == target:</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line">    <span class="keyword">elif</span> arr[start] == target:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<ul>
<li>已排序很重要，而且排序是降序还是升序写法也不一样。</li>
<li>写程序先写异常处理，这里对应的是数组为空的情况。</li>
<li>start 和 end 分别初始化为 0 和 array.size() - 1。</li>
<li>取中值使用 mid = start + (end - start) / 2; 目的是为了防止 start + end 的值超出int范围发生溢出错误。</li>
<li>循环停止条件为 start &lt; end-1;没有等号，如果取等号，那么有可能进入死循环，如：start = 1； end = 2； 那么 mid = 1；那么此时如果令 start = mid，程序将进入死循环。</li>
<li>循环停止时肯定有 start + 1 == end；或者数组元素只有一个，也就是说 start 和 end 要么相邻（数组元素个数大于1），要么相交（数组元素个数为1），那么都可以归结为最后的判断语句，根据题目的要求（第一次出现还是最后一次出现）确定判断顺序。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="旋转的数组的最小值"><a href="#旋转的数组的最小值" class="headerlink" title="旋转的数组的最小值"></a>旋转的数组的最小值</h3><p>假设一个旋转排序的数组其起始位置是未知的（比如<code>[0 1 2 4 5 6 7]</code> 可能变成是<code>[4 5 6 7 0 1 2]</code>）。<br>你需要找到其中最小的元素。<br>假设数组中不存在重复的元素。<br><strong>思路：</strong> 由最小值为中心把两边分开，两边都是递增的，而后一部分的最大值也严格小于前一部分的所有值，显然，最后一部分的最大值就是num[n-1]那么我们只需要找到比这个值小的第一个值即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(nums)</span>:</span></span><br><span class="line">    start, end = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    target = nums[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end])</span><br></pre></td></tr></table></figure></p>
<h3 id="旋转排序数组中的最小值-II"><a href="#旋转排序数组中的最小值-II" class="headerlink" title="旋转排序数组中的最小值 II"></a>旋转排序数组中的最小值 II</h3><p>假设包含重复值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(nums)</span>:</span></span><br><span class="line">    start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[end]:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[end]:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = end - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end])</span><br></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/梯度下降法及牛顿法详解/" class="prev">PREV</a><a href="/算法之排列组合问题/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Gustee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>