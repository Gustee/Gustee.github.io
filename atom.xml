<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸡Gustee的挣扎</title>
  
  <subtitle>:)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-03T08:14:03.193Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gustee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集成学习</title>
    <link href="http://yoursite.com/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/集成学习/</id>
    <published>2019-06-03T07:48:12.000Z</published>
    <updated>2019-06-03T08:14:03.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h1><p>集成学习主要分为bossting和bagging</p><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>Boosting方法训练基分类器时采用串行的方式，各个基分类器之间有依赖。<br>Boosting的思想是每一个基分类器纠正前一个基分类器的错误。根据纠正的方式的不同，就有了不同的boosting算法。比如通过调整样本权重分布训练基分类器，对应的Adaboost。通过拟合前一个基分类器与目标值损失的负梯度<code>[注：当损失函数是平方损失时，才能叫残差，一遍的损失是残差的近似]</code>来学习下一个基分类器的方法就是GBDT。</p><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>与boosting的串行训练的方式不同，bagging在训练过程中，各个基分类器之前无强依赖，可以进行并行训练，为了让基分类器之间互相独立，将训练集分为若干个子集，每个基分类器进行单独的学习，由于分类器之间存在差异，在最终决策时，每个个体单独预测，然后通过投票或者平均的方式做出最终的决策</p><h2 id="从偏差和方差的角度看boosting和bagging"><a href="#从偏差和方差的角度看boosting和bagging" class="headerlink" title="从偏差和方差的角度看boosting和bagging"></a>从偏差和方差的角度看boosting和bagging</h2><p>基分类器一般都是错误率较高的若分类器。基分类器的误差是偏差和方差之和，偏差主要是由于分类器的表达能力有限导致的，表现在训练误差不收敛。方差是由于分类器对样本分布过于敏感，产生过拟合<br>Boosting方法通过逐步聚焦于基分类器分错的样本，减少集成分类器的偏差，bagging方法则采取分而治之的方法，通过对训练样本多次采样，并行训练多个不同模型，然后综合，来减少集成分类器的方差。</p><h2 id="bagging减小方差的证明"><a href="#bagging减小方差的证明" class="headerlink" title="bagging减小方差的证明"></a>bagging减小方差的证明</h2><p>假设有n个随机变量，方差为$ \sigma ^2 $，两两变量之间的相关性为$ \rho $，则有n个随机变量的均值为$\frac{1}{n}\sum x_i$，方差为$ \rho \cdot \sigma ^2 + (1-\rho) \cdot \sigma ^2 / n $<br>在随机变量完全独立的情况下，n个随机变量的方差为$\frac{1}{n}\sigma ^2$，则方差减小到原来的$\frac{1}{n}$<br>证明如下：<br><img src="/集成学习/pic.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成学习&quot;&gt;&lt;a href=&quot;#集成学习&quot; class=&quot;headerlink&quot; title=&quot;集成学习&quot;&gt;&lt;/a&gt;集成学习&lt;/h1&gt;&lt;p&gt;集成学习主要分为bossting和bagging&lt;/p&gt;
&lt;h2 id=&quot;Boosting&quot;&gt;&lt;a href=&quot;#Boost
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>梯度下降法及牛顿法详解</title>
    <link href="http://yoursite.com/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E5%8F%8A%E7%89%9B%E9%A1%BF%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/梯度下降法及牛顿法详解/</id>
    <published>2019-06-03T04:56:09.000Z</published>
    <updated>2019-06-03T05:17:22.640Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">    MathJax.Hub.Config({        tex2jax: {        inlineMath: [['$','$'], ['\\(','\\)']],        processEscapes: true        }    });</script><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>对于函数$f:R^n\rightarrow R$，输入为$\vec x = (x_1, x_2, x_3, \dots,x_n)^T$</p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>定义函数的梯度为：</p><script type="math/tex; mode=display">\nabla_{\vec x} f(\vec x) = \left(\frac{\partial f(\vec x)}{x_1}, \frac{\partial f(\vec x)}{x_2},\dots, \frac{\partial f(\vec x)}{x_n}\right)^T</script><h3 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h3><p>方向导数：一个标量场在某点沿着某个向量方向上的方向导数，描绘了该点附近标量场沿着该向量方向变动时的瞬时变化率。<br>沿着方向$\vec u$的方向导数表示在$\vec x$处，沿着方向$\vec u$，函数的增长率，定义为：</p><script type="math/tex; mode=display">\lim_{\alpha \rightarrow 0}\frac{f(\vec x + \alpha \vec u) - f(\vec x)}{\alpha},其中\vec u为单位向量\\ =\vec u^T \nabla_{\vec x}f(\vec x)</script><p><code>梯度为一个矢量，方向导数为一个标量</code></p><h3 id="梯度下降法-1"><a href="#梯度下降法-1" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>为了最小化$f$，则需要寻找一个方向$\vec u$，沿着该方向，函数减少的速度最快，即：</p><script type="math/tex; mode=display">\max \limits_{\vec u}-\vec u^T \nabla_{\vec x}f(\vec x) \\s.t.||\vec u||_2=1</script><p>即：</p><script type="math/tex; mode=display">\min \limits_{\vec u}\vec u^T \nabla_{\vec x}f(\vec x) \\s.t.||\vec u||_2=1</script><p>设$\vec u$与梯度的夹角为$\theta$，则所求的$\theta$为：</p><script type="math/tex; mode=display">\theta ^*=\min \limits_\theta||\vec u||_2||\nabla_{\vec x}f(\vec x)||_2cos\theta</script><p>又因为$||\vec u||_2=1$,且夹角$\theta$与梯度的模长无关</p><script type="math/tex; mode=display">\theta ^*=\min cos\theta</script><p>则当$\theta=π$时，即当$\vec u$为沿着梯度的反方向时，函数值减小的速率最快。</p><p>梯度下降求解过程：<br><img src="/梯度下降法及牛顿法详解/GD.png" alt="GD"><br><code>学习率的选择方法:</code></p><ul><li>选择一个小的正常数</li><li>线性搜索，给定一个学习率集合，每次迭代选择使得目标函数下降最大的学习率</li><li>最速下降法。</li></ul><p><code>当目标函数为凸函数时，梯度下降法的解为全局最优解</code></p><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><h3 id="海森矩阵"><a href="#海森矩阵" class="headerlink" title="海森矩阵"></a>海森矩阵</h3><p>当函数的输入为多维时，定义海森矩阵：<br><img src="/梯度下降法及牛顿法详解/HS.png" alt="HS"><br>观察矩阵结构可以看出，当函数的二阶偏导数连续时，海森矩阵是对称的。</p><h3 id="梯度下降法的缺点"><a href="#梯度下降法的缺点" class="headerlink" title="梯度下降法的缺点"></a>梯度下降法的缺点</h3><p>将$f(\vec x)$在$x_0$出泰勒展开：</p><script type="math/tex; mode=display">f ( \vec { \mathbf { x } } ) \approx f \left( \vec{ \mathbf { x } } _ { 0 } \right) + \left( \vec{ \mathbf { x } } - \vec{ \mathbf { x } } _ { 0 } \right) ^ { T } \vec{ \mathbf { g } } + \frac { 1 } { 2 } \left( \vec{ \mathbf { x } } - \vec{ \mathbf { x } } _ { 0 } \right) ^ { T } \mathbf { H } \left( \vec{ \mathbf { x } } - \vec{ \mathbf { x } } _ { 0 } \right)</script><p>其中$\vec g$为$\vec x_0$处的梯度，$H$为$\vec x_0$处的海森矩阵。<br>根据梯度下降法：$\vec{ \mathbf { x } } ^ { k+1 } = \vec{ \mathbf { x } }^{k} - \epsilon \vec g$<br>根据泰勒公式：</p><script type="math/tex; mode=display">f ( \vec { \mathbf { x } }^{<K+1>} ) \approx f \left( \vec{ \mathbf { x } } ^ { k } \right) - \epsilon \vec{ \mathbf { g } } ^ { T } \vec{ \mathbf { g } } + \frac { 1 } { 2 } \epsilon ^ { 2 } \vec{ \mathbf { g } } ^ { T } \mathbf { H } \vec{ \mathrm { g } }</script><p>观察上式，若$\frac { 1 } { 2 } \epsilon ^ { 2 } \vec{ \mathbf { g } } ^ { T } \mathbf { H } \vec{ \mathrm { g } }$很大时，$f ( \vec { \mathbf { x } }^{ K+1 } ) &gt; f ( \vec { \mathbf { x } }^{  K } )$，此时沿着负梯度，函数值反而在增大，则：</p><ul><li>如果 $\epsilon ^ { 2 } \vec{ \mathbf { g } } ^ { T } \mathbf { H } \vec{ \mathrm { g } } &lt; 0$，则无论$\epsilon$取多大的值，函数值都是持续减小的</li><li>如果 $\epsilon ^ { 2 } \vec{ \mathbf { g } } ^ { T } \mathbf { H } \vec{ \mathrm { g } } &gt; 0$，则只有当$\epsilon$很小时，函数值才会持续减小。</li></ul><h3 id="牛顿法-1"><a href="#牛顿法-1" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>牛顿法就是在梯度下降中加入和目标函数二阶导数的信息。<br>设$\vec x$第k次的迭代值为$\vec x ^ { k }$,第k+1次的迭代值为$\vec x^{ k+1 }$同样对目标函数在$\vec x_k$泰勒展开：</p><script type="math/tex; mode=display">f ( \vec { \mathbf { x } } ) \approx f \left( \vec{ \mathbf { x } } ^ { \ <k> } \right) + \left( \vec{ \mathbf { x } } - \vec{ \mathbf { x } } ^ { \ <k> } \right) ^ { T } \vec{ \mathbf { g }_{k} } + \frac { 1 } { 2 } \left( \vec{ \mathbf { x } } - \vec{ \mathbf { x } } ^ { \ <k> } \right) ^ { T } \mathbf { H }_{k} \left( \vec{ \mathbf { x } } - \vec{ \mathbf { x } } ^ { \ <k> } \right)</script><p>当$\vec x$为极值，则满足$\frac{\partial f(\vec x)}{\partial \vec x}=\vec 0$，若经过k+1次迭代后求得极值，则满足$\frac{\partial f(\vec x^{,k+1})}{\partial \vec x^{k+1}}=\vec 0$，带入上式有：</p><script type="math/tex; mode=display">\vec g_k + \vec H_k \left(\vec x^{\ <k+1>}-\vec x^{\ <k>}\right)=\vec 0</script><p>最后求得:</p><script type="math/tex; mode=display">\vec x^{\ <k+1>} = \vec x^{\ <k>} - \vec H_k^{-1} \cdot \vec g_k</script><p>牛顿法迭代过程</p><p><img src="/梯度下降法及牛顿法详解/ND.png" alt="ND"><br>牛顿法的缺点：</p><ul><li>计算海森矩阵的逆开销较大</li><li>当位于鞍点附近时，牛顿法效果很差，因为牛顿法会主动跳入鞍点。</li></ul><h3 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h3><p>在牛顿法的迭代中，需要计算海森矩阵的逆矩阵$H^{-1}$，这一计算比较复杂。可以考虑用一个矩阵$G$来代替海森矩阵的逆矩阵。<br>矩阵$G$需要满足的条件:</p><ul><li>正定</li><li>满足拟牛顿条件<br>$\lfet( \vec g<em>{k+1}  - \vec g</em>{k} \right) = H_k \cdot \left(\vec x^{ k+1 }-\vec x^{ k }\right)$</li></ul><p>常见的逆牛顿算法</p><ul><li>DFP算法</li><li>BFGS算法</li><li>Broyden类算法</li></ul><p>参考：<br>《统计学习方法》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
        tex2jax: {
        inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]],
        pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二分查找及其应用</title>
    <link href="http://yoursite.com/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/二分查找及其应用/</id>
    <published>2019-06-02T15:21:30.000Z</published>
    <updated>2019-06-02T15:29:58.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通的二分查找法"><a href="#普通的二分查找法" class="headerlink" title="普通的二分查找法"></a>普通的二分查找法</h2><p>给定一个排序的整数数组（升序）和一个要查找的整数<code>target</code>，用<code>O(logn)</code>的时间查找到target出现的下标（从0开始），如果target不存在于数组中，返回<code>-1</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, target)</span>:</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = len(arr)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3 id="修改过的二分查找法"><a href="#修改过的二分查找法" class="headerlink" title="修改过的二分查找法"></a>修改过的二分查找法</h3><p>给定一个排序的整数数组（升序）和一个要查找的整数<code>target</code>，用<code>O(logn)</code>的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回<code>-1</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, target)</span>:</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = len(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid</span><br><span class="line">    <span class="keyword">if</span> arr[start] == target:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">elif</span> arr[end] == target:</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>若将条件改为查找target最后一次出现的下标（从0开始），那么程序将发生改变，循环中如果 arr[mid] = target, 则 start = mid; 且最后的边界判断改为先判断arr[end] == target; 其他不变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, target)</span>:</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = len(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> arr[end] == target:</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line">    <span class="keyword">elif</span> arr[start] == target:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong></p><ul><li>已排序很重要，而且排序是降序还是升序写法也不一样。</li><li>写程序先写异常处理，这里对应的是数组为空的情况。</li><li>start 和 end 分别初始化为 0 和 array.size() - 1。</li><li>取中值使用 mid = start + (end - start) / 2; 目的是为了防止 start + end 的值超出int范围发生溢出错误。</li><li>循环停止条件为 start &lt; end-1;没有等号，如果取等号，那么有可能进入死循环，如：start = 1； end = 2； 那么 mid = 1；那么此时如果令 start = mid，程序将进入死循环。</li><li>循环停止时肯定有 start + 1 == end；或者数组元素只有一个，也就是说 start 和 end 要么相邻（数组元素个数大于1），要么相交（数组元素个数为1），那么都可以归结为最后的判断语句，根据题目的要求（第一次出现还是最后一次出现）确定判断顺序。</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="旋转的数组的最小值"><a href="#旋转的数组的最小值" class="headerlink" title="旋转的数组的最小值"></a>旋转的数组的最小值</h3><p>假设一个旋转排序的数组其起始位置是未知的（比如<code>[0 1 2 4 5 6 7]</code> 可能变成是<code>[4 5 6 7 0 1 2]</code>）。<br>你需要找到其中最小的元素。<br>假设数组中不存在重复的元素。<br><strong>思路：</strong> 由最小值为中心把两边分开，两边都是递增的，而后一部分的最大值也严格小于前一部分的所有值，显然，最后一部分的最大值就是num[n-1]那么我们只需要找到比这个值小的第一个值即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(nums)</span>:</span></span><br><span class="line">    start, end = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    target = nums[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid</span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end])</span><br></pre></td></tr></table></figure></p><h3 id="旋转排序数组中的最小值-II"><a href="#旋转排序数组中的最小值-II" class="headerlink" title="旋转排序数组中的最小值 II"></a>旋转排序数组中的最小值 II</h3><p>假设包含重复值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(nums)</span>:</span></span><br><span class="line">    start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[end]:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[end]:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = end - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> min(nums[start], nums[end])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;普通的二分查找法&quot;&gt;&lt;a href=&quot;#普通的二分查找法&quot; class=&quot;headerlink&quot; title=&quot;普通的二分查找法&quot;&gt;&lt;/a&gt;普通的二分查找法&lt;/h2&gt;&lt;p&gt;给定一个排序的整数数组（升序）和一个要查找的整数&lt;code&gt;target&lt;/code&gt;，用&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法之排列组合问题</title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/算法之排列组合问题/</id>
    <published>2019-06-02T14:45:07.000Z</published>
    <updated>2019-06-02T14:49:45.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排列组合问题"><a href="#排列组合问题" class="headerlink" title="排列组合问题"></a>排列组合问题</h1><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><p><strong>排列：</strong> 一般地，从n个不同元素中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列(permutation)。特别地，当m=n时，这个排列被称作全排列(all permutation)。</p><h3 id="数组的全排列"><a href="#数组的全排列" class="headerlink" title="数组的全排列"></a>数组的全排列</h3><p>我们以<code>[1,2,3]</code>为例，首先我们从数组中选取数字<code>1</code>，然后和剩下的<code>[2,3]</code>组成的子排列构成全排列；然后从数组中选取数字<code>2</code>，然后和剩下的<code>[1,3]</code>组成的子排列构成全排列；最后从数组中选取数字<code>3</code>，然后和剩下的<code>[1,2]</code>组成的子排列构成全排列。详细的递归过程如下：<br><img src="/算法之排列组合问题/%E6%8E%92%E5%88%97.png" alt="排列"><br>代码实现细节：<br><code>index</code>表示向当前排列添加第<code>index</code>个元素。<br><code>p</code>表示当前的排列，其中拥有<code>index-1</code>个元素。<br>当<code>index</code>与数组长度相等时，说明一个全排列构造完成，保存该排列。否则，从<code>array</code>数组中选出一个未出现在<code>p</code>中的元素，加入当前排列，然后函数继续添加下一个位置的元素。<br><strong>注意：</strong> 使用当前元素构造排列完成保存后，要将该元素弹出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(array)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># p表示当前生成的排列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generatePermutation</span><span class="params">(array, index, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == len(array):</span><br><span class="line">            res.append(p.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">                p.append(i)</span><br><span class="line">                generatePermutation(array, index+<span class="number">1</span>, p)</span><br><span class="line">                p.pop()</span><br><span class="line">    generatePermutation(array, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3 id="普通排列"><a href="#普通排列" class="headerlink" title="普通排列"></a>普通排列</h3><p>从上文的全排列可以很容易的推广到普通的排列，只需要更改上面代码的排列构造完全的条件即可，<br><code>当index等于k时，当前的排列即构造完成，保存</code>，实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(array, k)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generatePermutation</span><span class="params">(array, index, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == k:</span><br><span class="line">            res.append(p.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">                p.append(i)</span><br><span class="line">                generatePermutation(array, index+<span class="number">1</span>, p)</span><br><span class="line">                p.pop()</span><br><span class="line">    generatePermutation(array, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3 id="重复排列"><a href="#重复排列" class="headerlink" title="重复排列"></a>重复排列</h3><p>重复排列(permutationwith repetiton)是一种特殊的排列。从n个不同元素中可重复地选取m个元素。按照一定的顺序排成一列，称作从n个元素中取m个元素的可重复排列。当且仅当所取的元素相同，且元素的排列顺序也相同，则两个排列相同。<code>只需将上面普通排列代码中判断数组元素是否在当前排列中的条件去掉即可</code>，实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(array, k)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generatePermutation</span><span class="params">(array, index, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == k:</span><br><span class="line">            res.append(p.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            p.append(i)</span><br><span class="line">            generatePermutation(array, index+<span class="number">1</span>, p)</span><br><span class="line">            p.pop()</span><br><span class="line">    generatePermutation(array, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p><strong>组合：</strong> 一般地，从n个不同的元素中，任取m（m≤n）个元素为一组，叫作从n个不同元素中取出m个元素的一个组合。</p><h3 id="数组的组合"><a href="#数组的组合" class="headerlink" title="数组的组合"></a>数组的组合</h3><p>我们以<code>[1,2,3，4]</code>中取<code>2</code>个数为例。在<code>[1,2,3,4]</code>中取<code>1</code>与排序相同，与排列不同的是，组合不考虑取出元素的顺序，所以在<code>[1,2,3,4]</code>中取<code>2</code>之后，只能在<code>[3,4]</code>中继续取值，因为之前已经计算出了所有包含<code>1</code>的组合。同理在<code>[1,2,3,4]</code>中取<code>3</code>之后，只能在<code>[4]</code>中取值。<br><img src="/算法之排列组合问题/%E7%BB%84%E5%90%88.png" alt="组合"><br><code>start</code>表示需要从数组的<code>start</code>位置开始搜索元素加入当前组合<code>c</code>中。<br><code>c</code>表示当前的组合。<br>当当前组合的长度等于k时，组合构造完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateCombinations</span><span class="params">(nums, start, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(c) == k:</span><br><span class="line">            res.append(c.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            c.append(nums[i])</span><br><span class="line">            generateCombinations(nums, i+<span class="number">1</span>, c)</span><br><span class="line">            c.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    generateCombinations(nums, <span class="number">0</span>, [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="LeedCode-Combination-Sum"><a href="#LeedCode-Combination-Sum" class="headerlink" title="LeedCode-Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">LeedCode-Combination Sum</a></h3><p><em>给出一个集合，其中所有的元素各不相同，以及一个数字T。寻找所有该集合中元素组合，使得组合中所有的元素和为T（集合中每一个元素可以使用多次）</em></p><ul><li>给定集合nums=[2,3,6,7], T=7`</li><li>返回[[7],[2,2,3]]</li></ul><hr><p><code>index</code>表示从集合的<code>index</code>的位置往后查找候选元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(candidates, index, target, cur_res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(cur_res.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> target &gt;= candidates[i]:</span><br><span class="line">                    cur_res.append(candidates[i])</span><br><span class="line">                    <span class="comment"># 由于每个元素可以使用多次，所以下次寻找候选元素还是从当前位置继续，而不是从下一个位置继续</span></span><br><span class="line">                    fun(candidates, i, target-candidates[i], cur_res)</span><br><span class="line">                    cur_res.pop()</span><br><span class="line"></span><br><span class="line">        fun(candidates, <span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3 id="LeetCode-Subsets"><a href="#LeetCode-Subsets" class="headerlink" title="LeetCode-Subsets"></a><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">LeetCode-Subsets</a></h3><p><em>给出一个集合，其中所有的元素各不相同。求出该集合的所有字集。</em></p><ul><li>给定集合nums=[1,2,3]</li><li>返回[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]</li></ul><hr><p>第一种解法，n个元素的子集可以看做是$C_n^0, C_n^1,C_n^2,\cdots,C_n^k,\cdots,C_n^n$所有排列的集合，则在实现上与组合问题的区别即为不用判断当前当前的结果是否等于k，因为求子集需要k把0到n所有的数都要取一遍。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(nums, start, cur_res)</span>:</span></span><br><span class="line">            res.append(cur_res.copy())</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">                cur_res.append(nums[i])</span><br><span class="line">                fun(nums, i + <span class="number">1</span>, cur_res)</span><br><span class="line">                cur_res.pop()</span><br><span class="line"></span><br><span class="line">        fun(nums, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><hr><p>第二种解法，<code>对每个元素，有两种可能，加入当前组合和不加入组合</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(nums, index, cur_res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == len(nums):</span><br><span class="line">                res.append(cur_res.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 将当前元素不加入该组合</span></span><br><span class="line">            fun(nums, index+<span class="number">1</span>, cur_res)</span><br><span class="line">            <span class="comment"># 将当前元素加入该组合，</span></span><br><span class="line">            cur_res.append(nums[index])</span><br><span class="line">            fun(nums, index+<span class="number">1</span>, cur_res)</span><br><span class="line">            cur_res.pop()</span><br><span class="line"></span><br><span class="line">        fun(nums, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排列组合问题&quot;&gt;&lt;a href=&quot;#排列组合问题&quot; class=&quot;headerlink&quot; title=&quot;排列组合问题&quot;&gt;&lt;/a&gt;排列组合问题&lt;/h1&gt;&lt;h2 id=&quot;排列问题&quot;&gt;&lt;a href=&quot;#排列问题&quot; class=&quot;headerlink&quot; title=&quot;排
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序基础</title>
    <link href="http://yoursite.com/%E6%8E%92%E5%BA%8F%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/排序基础/</id>
    <published>2019-06-02T14:38:39.000Z</published>
    <updated>2019-06-02T14:44:29.804Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讨论基于数组的基础排序算法，包括冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序。</p><p>为了代码的可读性，定义交换数组中交换两个位置的元素的工具函数（虽然用python写起来也非常方便）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    array[l], array[r] = array[r], array[l]</span><br></pre></td></tr></table></figure></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h3><p>为数组<code>[6, 3, 5, 7, 0, 4, 1, 2]</code>排序为例。首先排序的范围是<code>[0, n-1]</code>，如果前面的数比后面的数大，则交换位置，直到最大的数位于数组的最后；然后第二轮排序的范围变为<code>[0, n-2]</code>，第二轮结束后，数组第二大的数会放置在数组的倒数第二个位置；依次进行这样的排序过程，直到待排序的范围变成数组的第一个数，此时整个数组的排序完成，数组变的有序。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                swap(arr, i, j)</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(n^2)$<br><strong>空间复杂度：</strong> $O(1)$</p><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="排序过程-1"><a href="#排序过程-1" class="headerlink" title="排序过程"></a>排序过程</h3><p>同样以数组<code>[6, 3, 5, 7, 0, 4, 1, 2]</code>为例。首先在数组<code>[0, n-1]</code>范围上选出一个最小值放在数组0位置；然后在数组<code>[1, n-1]</code>范围上选出一个最小值放在数组1位置；直到最后待排序范围只剩下数组最后一个数时，此时整个数组的排序完成，数组变的有序。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    min_index = <span class="number">0</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        swap(arr, i, min_index)</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(n^2)$<br><strong>空间复杂度：</strong> $O(1)$</p><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="排序过程-2"><a href="#排序过程-2" class="headerlink" title="排序过程"></a>排序过程</h3><p>同样以数组<code>[6, 3, 5, 7, 0, 4, 1, 2]</code>为例。首先位置1上的数和位置0上的数进行比较，如果位置1上的数更小，则和位置0上的数交换；接下来考察位置2上面的数，如果位置2上的数比位置1小，则交换，然后继续和位置0上的数比较。假设当前考察的是数组第k个元素m，首先比较位置k-1上的数和m的大小，若大于m则交换，继续将m和位置k-2上的数比较，直到位置k-x上的数，小于等于m；直到考察完数组中所有的元素。<br><strong>note:</strong> 假如当前考察位置k上的元素，则位置<code>[0,k-1]</code>上的数一定是有序的。所以每一轮的排序实质是将当前数插入到该位置之前的有序数组中，使得增加该数后数组仍热有序。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> arr[j] &lt; arr[j<span class="number">-1</span>]:</span><br><span class="line">            swap(arr, j, j - <span class="number">1</span>)</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(n^2)$<br><strong>空间复杂度：</strong> $O(1)$</p><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="排序过程-3"><a href="#排序过程-3" class="headerlink" title="排序过程"></a>排序过程</h3><p>以数组<code>[6, 5, 2, 1, 4, 3, 8, 7]</code>为例。首先让数组中的每一个数单独成为长度为1的有序区间。然后把相邻的长度为1的有序区间进行合并，得到最大长度为2的有序区间。接下来再把相邻有序区间进行合并，得到最大长度为4的有序区间。依次这样进行下去，直到两个长度为<code>n/2</code>的有序区间合并成为长度为<code>n</code>的有序区间，此时整个数组有序。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数组arr的[l, m]和[m+1, r]已经有序，合并两个区间，使其[l, r]范围有序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arr, l, m, r)</span>:</span></span><br><span class="line">        temp = []</span><br><span class="line">        p1 = l</span><br><span class="line">        p2 = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> arr[p1] &lt;= arr[p2]:</span><br><span class="line">                temp.append(arr[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.append(arr[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">        <span class="comment"># p1和p2必有且只有越界</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">            temp.append(arr[p1])</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">            temp.append(arr[p2])</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">            arr[l+i] = temp[i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r: <span class="comment"># 范围内只有一个数</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        merge_sort(arr, l, mid)</span><br><span class="line">        merge_sort(arr, mid+<span class="number">1</span>, r)</span><br><span class="line">        merge(arr, l, mid, r)</span><br><span class="line">    n = len(arr)</span><br><span class="line">    merge_sort(arr, <span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(nlog(n))$<br><strong>空间复杂度：</strong> $O(n)$</p><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="排序过程-4"><a href="#排序过程-4" class="headerlink" title="排序过程"></a>排序过程</h3><p>随机在数组中选择一个数，然后让小于等于该数的元素放在该数的左边，大于这个该数的元素放在该数的右边，接下来对该数左右两边的数分别递归的调用上述排序过程，直到整个数组都有序。关于数组划分的方法可以参考<a href="https://gustee.github.io/2019/06/02/数组划分/" target="_blank" rel="noopener">另一篇文章</a></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">        pivot = arr[r]</span><br><span class="line">        small = l - <span class="number">1</span></span><br><span class="line">        big = r + <span class="number">1</span></span><br><span class="line">        cur = l</span><br><span class="line">        <span class="keyword">while</span> cur != big:</span><br><span class="line">            <span class="keyword">if</span> arr[cur] &lt; pivot:</span><br><span class="line">                small += <span class="number">1</span></span><br><span class="line">                swap(arr, cur, small)</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[cur] &gt; pivot:</span><br><span class="line">                big -= <span class="number">1</span></span><br><span class="line">                swap(arr, cur, big)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> small + <span class="number">1</span>, big - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &lt; r:</span><br><span class="line">            ll, rr = partition(arr, l, r)</span><br><span class="line">            quick_sort(arr, l, ll<span class="number">-1</span>)</span><br><span class="line">            quick_sort(arr, rr+<span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line">    quick_sort(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(nlog(n))$<br><strong>空间复杂度：</strong> $O(log(n))$~$O(n)$<code>取决于划分的具体情况</code></p><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>概念：</strong> 堆通常是一个可以被看做一棵完全二叉树的数组对象。堆总是满足下列性质：</p><ul><li>堆中某个节点的值总是不大于或不小于其父节点的值；</li><li>堆总是一棵完全二叉树。</li></ul><p>其中若某个节点的值总是不大于其父节点的值，这样的堆称为大根堆，反之称为小根堆<br>因为堆的存储结构通常是数组，所以可以通过数组的索引表示二叉树节点间的关系</p><ul><li><code>array[i]</code>的左孩子节点为<code>array[2*i+1]</code>，右孩子节点为<code>array[2*i+2]</code></li><li><code>array[i]</code>的父节点为<code>array[(i-1)/2]</code></li></ul><h3 id="堆的构建"><a href="#堆的构建" class="headerlink" title="堆的构建"></a>堆的构建</h3><p>假设数组<code>[0, i-1]</code>范围的元素已经构成大根堆，将<code>i</code>位置的元素加入到大根堆。若<code>i</code>位置的数比其父节点的数大，则与其父节点交换位置，然后继续与其新的父节点比较，直到该元素小于其父节点为止，此时，数组<code>i</code>位置的元素成功插入大根堆，大根堆的范围变为<code>[0, i]</code>。<br>参考代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将arr[i]插入到大根堆，使数组[0, i]范围构成大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(arr, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> arr[i] &gt; arr[int((i<span class="number">-1</span>)/<span class="number">2</span>)]:</span><br><span class="line">            swap(arr, i, int((i<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">            i = int((i<span class="number">-1</span>)/<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h3 id="堆的调整"><a href="#堆的调整" class="headerlink" title="堆的调整"></a>堆的调整</h3><p>假设数组<code>[0, size]</code>范围的元素已经构成大根堆，假设数组<code>index</code>位置的值发生改变，调整堆结构，使其重新构成大根堆。假设该节点存在左孩子，且同时存在右孩子，则取左右孩子的最大值，与该节点的值比较，若该节点的值大于最大的孩子节点，则不用调整，否则与较大的孩子交换位置，然后继续与新的孩子节点的值比较大小，判断是否需要继续下沉，直到该节点大于所有的孩子节点，重新调成为堆结构。<br>参考代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, index, size)</span>:</span></span><br><span class="line">    <span class="comment"># 左孩子的索引</span></span><br><span class="line">    left =  <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; size:</span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若右孩子存在，返回两个孩子中较大的索引，否则返回左孩子索引</span></span><br><span class="line">        max_children = right <span class="keyword">if</span> (right&lt;size <span class="keyword">and</span> arr[right]&gt;arr[left]) <span class="keyword">else</span> left</span><br><span class="line">        <span class="comment"># 若当前节点的值大于孩子中的最大值，则不需要调整，否则交换</span></span><br><span class="line">        <span class="keyword">if</span> arr[index] &gt; arr[max_children]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        swap(arr, index, max_children)</span><br><span class="line">        <span class="comment"># 更新该值的新索引，以进一步判断是否需要继续调整</span></span><br><span class="line">        index = max_children</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3 id="排序过程-5"><a href="#排序过程-5" class="headerlink" title="排序过程"></a>排序过程</h3><p>首先将数组中的n个数构造成为一个大根堆，我们知道堆顶是所有元素的最大值，我们将堆顶元素和堆的最后一个元素进行交换，然后把最大值脱离整个堆结构，放在数组的最后的位置，作为数组的有序部分保存下来；接下来重新将数组<code>[0, n-2]</code>范围的n-1个数重新调整为大根堆，然后将新堆顶元素和堆的最后一个元素进行交换，然后把最大值脱离整个堆结构，放在数组的倒数第二的位置，作为数组的有序部分保存下来。这样每次从堆顶弹出一个元素，堆的大小也依次减1，当堆的大小减为1时，整个数组有序。</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(arr, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> arr[i] &gt; arr[int((i<span class="number">-1</span>)/<span class="number">2</span>)]:</span><br><span class="line">            swap(arr, i, int((i<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">            i = int((i<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, index, size)</span>:</span></span><br><span class="line">        left =  <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; size:</span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line">            max_children = right <span class="keyword">if</span> (right&lt;size <span class="keyword">and</span> arr[right]&gt;arr[left]) <span class="keyword">else</span> left</span><br><span class="line">            <span class="keyword">if</span> arr[index] &gt; arr[max_children]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            swap(arr, index, max_children)</span><br><span class="line">            index = max_children</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        insert(arr, i)</span><br><span class="line">    heap_size = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> heap_size &gt; <span class="number">0</span>:</span><br><span class="line">        heap_size -= <span class="number">1</span>  <span class="comment"># 从堆顶弹出一个元素，堆大小减一</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, heap_size) <span class="comment"># 将元素放置堆外作为数组的有序部分</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heap_size)  <span class="comment"># 堆顶元素变化，重新调整堆结构</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(nlog(n))$<br><strong>空间复杂度：</strong> $O(1)$</p><h2 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h2><p><strong>概念：</strong> 假定待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，称这种排序算法是稳定的，否则称为不稳定的。</p><p>稳定：冒泡排序  插入排序  归并排序<br>不稳定：选择排序 快速排序 堆排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讨论基于数组的基础排序算法，包括冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序。&lt;/p&gt;
&lt;p&gt;为了代码的可读性，定义交换数组中交换两个位置的元素的工具函数（虽然用python写起来也非常方便）&lt;br&gt;&lt;figure class=&quot;highlight py
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组划分</title>
    <link href="http://yoursite.com/%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86/"/>
    <id>http://yoursite.com/数组划分/</id>
    <published>2019-06-02T14:34:40.000Z</published>
    <updated>2019-06-02T14:37:59.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Partition的两种写法"><a href="#Partition的两种写法" class="headerlink" title="Partition的两种写法"></a>Partition的两种写法</h1><p>快排中核心的方法应该算是Partition函数了，它的作用就是将整个数组分成小于基准值的左边，和大于基准值的右边。</p><p>定义函数签名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span></span></span><br></pre></td></tr></table></figure></p><p>表示按照array[l]的值，把数组中索引从l到r的部分的元素小于array[l]放在其左边，大于array[l]放在其右边。<br>为了代码的可读性，定义交换数组中交换两个位置的元素的工具函数（虽然用python写起来也非常方便）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    array[l], array[r] = array[r], array[l]</span><br></pre></td></tr></table></figure></p><h3 id="最常见的写法"><a href="#最常见的写法" class="headerlink" title="最常见的写法:"></a>最常见的写法:</h3><p>用两个指针l和r，一个指向头，一个指向尾，将头指针移动到第一个不满足A[l]<k的数，将尾移动到第一个不满足a[r]>=k的数，交换两个数，然后重复往下查找不满足A[l]<k和a[r]>=k的数，继续交换。直到两指针相撞<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    key = array[l]</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">while</span> array[r] &gt; key <span class="keyword">and</span> r &gt; l:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> array[l] &lt; key <span class="keyword">and</span> r &gt; l:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        swap(array, l, r)</span><br><span class="line">    array[r] = key</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></k和a[r]></k的数，将尾移动到第一个不满足a[r]></p><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>定义数组中(l-1, small]<code>[注：这里的(]表示左开右闭区间，即不包括l-1位置的元素，包括small位置的元素]</code>的区域为比key小的数，[big, r+1)<code>[注：左闭右开]</code>的区域为比key大的数，开始时两个区域中都没有数，将small初始化为l-1, big初始化为r+1。定义cur指针，指向当前遍历元素。当当前元素比key小时，将当前元素交换到small的右边，然后左边区域向右扩大一个，即small加1；当当前元素比key大时，将当前元素交换到big的左边，然后右边区域向左扩大一个，即big减一。函数最后返回划分完成之后第一个和最后一个等于key的元素的索引。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    key = array[l]</span><br><span class="line">    small = l - <span class="number">1</span></span><br><span class="line">    cur = l</span><br><span class="line">    big = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> cur != big:</span><br><span class="line">        <span class="keyword">if</span> array[cur] &lt; key:</span><br><span class="line">            small += <span class="number">1</span></span><br><span class="line">            swap(array, small, cur)</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> array[cur] &gt; key:</span><br><span class="line">            big -= <span class="number">1</span></span><br><span class="line">            swap(array, cur, big)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> small+<span class="number">1</span>, big<span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在数组中找到第k大的元素<br><strong>思路：</strong> 每次把一个元素交换到正确的位置，同时把左边的都放上大的，右边都放上小的。这个算法每一次选取一个枢纽元，排序之后，查看枢纽元的位置。如果它的位置大于K，就说明，要求出前面一个子序列的第K大的元素。反之，如果小于K，就说明要求出在后面一个序列的第K - 前一个序列的长度个元素。<br><code>注意，与快排不同的是，这个算法的时间复杂度是O(N)，因为第一次交换，算法复杂度为O(N)，接下来的过程和快速排序不同，快速排序是要继续处理两边的数据，再合并，合并操作的算法复杂度是O(1)，于是总的算法复杂度是O(N*logN)（可以这么理解，每次交换用了N，一共logN次）。但是这里在确定枢纽元的相对位置（在K的左边或者右边）之后不用再对剩下的一半进行处理。也就是说第二次插入的算法复杂度不再是O(N)而是O(N/2)，这不还是一样吗？其实不一样，因为接下来的过程是1+1/2+1/4+........ &lt; 2，换句话说就是一共是O(2N)的算法复杂度也就是O(N)的算法复杂度。</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthLargestElement</span><span class="params">(k, nums)</span>:</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        ll, rr = partition(nums, l, r)</span><br><span class="line">        <span class="keyword">if</span> ll &lt;= k - <span class="number">1</span> &lt;= rr:</span><br><span class="line">            <span class="keyword">return</span> nums[ll]</span><br><span class="line">        <span class="keyword">elif</span> k &gt; rr:</span><br><span class="line">            l = rr + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = ll - <span class="number">1</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Partition的两种写法&quot;&gt;&lt;a href=&quot;#Partition的两种写法&quot; class=&quot;headerlink&quot; title=&quot;Partition的两种写法&quot;&gt;&lt;/a&gt;Partition的两种写法&lt;/h1&gt;&lt;p&gt;快排中核心的方法应该算是Partition函
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的遍历种种</title>
    <link href="http://yoursite.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%A7%8D%E7%A7%8D/"/>
    <id>http://yoursite.com/二叉树的遍历种种/</id>
    <published>2019-06-02T14:31:22.000Z</published>
    <updated>2019-06-02T14:33:57.671Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的遍历主要有深度遍历和广度遍历两种，深度遍历就是指常见的先序、中序、后序三种遍历方法，广度遍历就是常说的层次遍历。</p><h2 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h2><ul><li>先序遍历：根节点 ——&gt; 先序遍历左子树 ——&gt; 先序遍历右子树</li><li>中序遍历：先序遍历左子树 ——&gt; 根节点 ——&gt; 先序遍历右子树</li><li>后序遍历：先序遍历左子树 ——&gt; 先序遍历右子树 ——&gt; 根节点<br>下图表示指针沿着图中箭头遍历整个二叉树的整个过程，可以看出对于树的每个节点指针都要经过它3次。若当指针第一次经过该节点时输出，得到的则为先序遍历；若当指针第二次经过该节点时输出，则为中序遍历；若当指针第三次经过该节点时输出，则为后序遍历。</li></ul><p>因为树的定义本身是递归定义，所以采用递归的方法实现树的三种基本遍历最容易理解，代码也最简介(本文所有代码基于Python3.6)。<br>树的节点定义如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>基于先序遍历的流程，先访问根节点，然后左子树，最后右子树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_pre_order</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        print(root.value)</span><br><span class="line">        recursion_pre_order(root.left)</span><br><span class="line">        recursion_pre_orderr(root.right)</span><br></pre></td></tr></table></figure></p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>根据中序遍历和先序遍历的差别，将访问根节点的代码调整到左右子树之间即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_in_order</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        recursion_in_order(root.left)</span><br><span class="line">        print(root.value)</span><br><span class="line">        recursion_in_order(root.right)</span><br></pre></td></tr></table></figure></p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历同理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_post_order</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        recursion_post_orde(root.left)</span><br><span class="line">        recursion_post_orde(root.right)</span><br><span class="line">        print(root.value)</span><br></pre></td></tr></table></figure></p><h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><h4 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h4><p> 用栈暂存二叉树的节点，根据栈的先进后出的性质，访问二叉树的根节点后先让右子树入栈，然后左子树入栈，即可在栈弹出时左子树先弹出，右子树后弹出，这样就满足了先序遍历的顺序。具体的遍历流程为：<br>首先需要先从栈顶取出节点，然后访问该节点，如果该节点不为空，则访问该节点，同时把该节点的右子树先入栈，然后左子树入栈<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_recursion_pre_order</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    s = []</span><br><span class="line">    s.append(root)</span><br><span class="line">    <span class="keyword">while</span>(len(s) != <span class="number">0</span>):</span><br><span class="line">        t = s.pop()</span><br><span class="line">        print(t.value)</span><br><span class="line">        <span class="keyword">if</span>(t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">            s.append(t.right)</span><br><span class="line">        <span class="keyword">if</span>(t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">            s.append(t.left)</span><br></pre></td></tr></table></figure></p><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>对于当前树，将自己左边界依次压入栈，然后弹出最左的节点输出，然后对弹出节点的右子树执行相同的操作，若其右子树为空，则继续访问栈顶节点。具体的遍历流程为：<br>若当前节点为空，栈中弹出一个节点输出，然后继续向右，若当前节点不为空，当前节点压入栈，然后当前节点往左。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_recursion_in_order</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">while</span>(len(s) != <span class="number">0</span> <span class="keyword">or</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            s.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = s.pop()</span><br><span class="line">            print(t.value)</span><br><span class="line">            root = t.right</span><br></pre></td></tr></table></figure></p><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历的顺序为先左子树，然后右子树，最后才是根节点。可以根据非递归的先序遍历先实现先根节点，然后右子树，最后左子树的顺序，然后用另一个辅助栈对该顺序逆序，即可得到先左子树，然后右子树，最后根节点的遍历顺序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_recursion_post_order</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    s = []</span><br><span class="line">    h = []</span><br><span class="line">    s.append(root)</span><br><span class="line">    <span class="keyword">while</span>(len(s) != <span class="number">0</span>):</span><br><span class="line">        t = s.pop()</span><br><span class="line">        h.append(t)</span><br><span class="line">        <span class="keyword">if</span>(t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">            s.append(t.right)</span><br><span class="line">        <span class="keyword">if</span>(t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">            s.append(t.left)</span><br><span class="line">    <span class="keyword">while</span>(len(h) != <span class="number">0</span>):</span><br><span class="line">        print(h.pop().value)</span><br></pre></td></tr></table></figure></p><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>使用队列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span><span class="params">(root)</span>:</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    q.put(root)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        node = q.get()</span><br><span class="line">        print(node.value, end=<span class="string">'  '</span>)</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            q.put(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            q.put(node.right)</span><br></pre></td></tr></table></figure></p><h3 id="拓展：按层打印二叉树"><a href="#拓展：按层打印二叉树" class="headerlink" title="拓展：按层打印二叉树"></a>拓展：按层打印二叉树</h3><p>使用一个变量记录当前遍历节点是否为该层的最右侧节点，如果是则换行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按层打印二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printByLevel</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    last = root</span><br><span class="line">    q.put(root)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        node = q.get()</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            q.put(node.left)</span><br><span class="line">            nlast = node.left</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            q.put(node.right)</span><br><span class="line">            nlast = node.right</span><br><span class="line">        </span><br><span class="line">        print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">if</span> last == node:</span><br><span class="line">            print()</span><br><span class="line">            last = nlast</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉树的遍历主要有深度遍历和广度遍历两种，深度遍历就是指常见的先序、中序、后序三种遍历方法，广度遍历就是常说的层次遍历。&lt;/p&gt;
&lt;h2 id=&quot;深度遍历&quot;&gt;&lt;a href=&quot;#深度遍历&quot; class=&quot;headerlink&quot; title=&quot;深度遍历&quot;&gt;&lt;/a&gt;深度遍历&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AUC若干计算方法及Python实现</title>
    <link href="http://yoursite.com/AUC%E8%8B%A5%E5%B9%B2%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%8F%8APython%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/AUC若干计算方法及Python实现/</id>
    <published>2019-06-02T14:17:26.000Z</published>
    <updated>2019-06-02T14:28:42.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据ROC曲线下的面积计算AUC"><a href="#根据ROC曲线下的面积计算AUC" class="headerlink" title="根据ROC曲线下的面积计算AUC"></a>根据ROC曲线下的面积计算AUC</h2><p>该方法的原理参考上一篇<a href="https://gustee.github.io/2019/06/02/分类问题的模型衡量指标/" target="_blank" rel="noopener">文章</a>关于AUC的讲解。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc</span><span class="params">(labels, preds)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roc</span><span class="params">(labels, preds)</span>:</span></span><br><span class="line">        n_pos = sum(labels)</span><br><span class="line">        n_neg = len(labels) - n_pos</span><br><span class="line">        labels_preds = zip(labels, preds)</span><br><span class="line">        labels_preds = sorted(labels_preds, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</span><br><span class="line">        threshold_list = sorted(list(set([<span class="number">0</span>, <span class="number">1</span>] + preds)), reverse=<span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        fpr_list = []</span><br><span class="line">        tpr_list = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> threshold <span class="keyword">in</span> threshold_list:</span><br><span class="line">            confusion_matrix = [[<span class="number">0</span>, <span class="number">0</span>], [n_pos, n_neg]]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(labels_preds)):</span><br><span class="line">                <span class="keyword">if</span> labels_preds[i][<span class="number">1</span>] &gt;= threshold:</span><br><span class="line">                    <span class="keyword">if</span> labels_preds[i][<span class="number">0</span>]:</span><br><span class="line">                        confusion_matrix[<span class="number">0</span>][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                        confusion_matrix[<span class="number">1</span>][<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        confusion_matrix[<span class="number">0</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                        confusion_matrix[<span class="number">1</span>][<span class="number">1</span>] -= <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line">            tpr_list.append(confusion_matrix[<span class="number">0</span>][<span class="number">0</span>] / (confusion_matrix[<span class="number">0</span>][<span class="number">0</span>] + confusion_matrix[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">            fpr_list.append(confusion_matrix[<span class="number">0</span>][<span class="number">1</span>] / (confusion_matrix[<span class="number">0</span>][<span class="number">1</span>] + confusion_matrix[<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fpr_list, tpr_list, threshold_list</span><br><span class="line">        </span><br><span class="line">    fprs, tprs, threshold = roc(labels, preds)</span><br><span class="line">    fprs_tprs = sorted(zip(fpr, tpr), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    area = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(fpr_tpr )):</span><br><span class="line">        area += (fprs_tprs [i - <span class="number">1</span>][<span class="number">1</span>] + fprs_tprs [i][<span class="number">1</span>]) * (fprs_tprs [i][<span class="number">0</span>] - fprs_tprs [i - <span class="number">1</span>][<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure></p><h2 id="根据AUC的另一意义"><a href="#根据AUC的另一意义" class="headerlink" title="根据AUC的另一意义"></a>根据AUC的另一意义</h2><p>AUC的另一意义：表示对于一个二分类模型，取任意一个正样本和负样本，正样本的模型输出(score)大于负样本的模型输出的概率。即可通过求出这个概率值来计算AUC。<br>设样本中有M个正样本，N个负样本，模型对样本的输出为score。存在(M*N)个正负样本对。对每一个正样本，统计负样本中样本的score比该正样本score小的负样本个数，最后除以总的正负样本对，得到所要求的概率值，即为AUC。<br>可以简介的表示为：</p><script type="math/tex; mode=display">AUC = \frac{\sum_{x \in psoitive}count(score小于x的负样本)}{M*N}\\ 其中count()表示样本的个数</script><p><code>实现细节：</code>按照score对样本排序，然后对每个正样本，统计该正样本score比小的负样本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc</span><span class="params">(labels, preds)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    先排序，然后统计有多少正负样本对满足：正样本预测值 &gt; 负样本预测值，再除以总的正负样本对个数</span></span><br><span class="line"><span class="string">    复杂度 O(NlogN)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n_pos = sum(labels)</span><br><span class="line">    n_neg = len(labels) - n_pos</span><br><span class="line"></span><br><span class="line">    labels_preds = zip(labels, preds)</span><br><span class="line">    labels_preds = sorted(labels_preds, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    accumulated_neg = <span class="number">0</span></span><br><span class="line">    statisfied_pair = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(labels_preds)):</span><br><span class="line">        <span class="keyword">if</span> labels_preds[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            statisfied_pair += accumulated_neg</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            accumulated_neg += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> statisfied_pair / (n_neg * n_pos)</span><br></pre></td></tr></table></figure></p><h2 id="基于rank计算AUC"><a href="#基于rank计算AUC" class="headerlink" title="基于rank计算AUC"></a>基于rank计算AUC</h2><p>该方法其实也是基于AUC的物理意义来计算。区别是先计算了每个正样本的rank值，然后根据rank值统计正样本score大于负样本score的样本对。<br>设样本中有M个正样本，N个负样本，模型对样本的输出为score。<br>对于正样本中score最高的，排序为$rank_1$，比该正样本score小的有$M-1$个正样本，$rank_1-M$个负样本。<br>同理，对于正样本中score第二高的，排序为$rank_2$，比该正样本score小的有$M-2$个正样本，$rank_2-(M-1)$个负样本，<br>以此类推，正样本中score最小的，排序为$rank_M$，比该正样本score小的有0个正样本，$rank_M-1$个负样本。<br>总共有$M*N$个正负样本对，则所有满足条件的正负样本对的个数为： $(rank_1-M + rank_2 - (M-1) + … + rank_M - 1)/(M*N)$<br>化简之后可以得到AUC的计算公式：</p><script type="math/tex; mode=display">AUC = \frac{\sum_{ins_{i}\in positive}^{}{rank_{ins_{i}}}-M*(M+1)/2}{M*N}</script><p>例子:<br><img src="/AUC若干计算方法及Python实现/samples.png" alt="例子"></p><p>对该例：$AUC=\frac{(2+4+5) - (0.5\times 3\times 4)}{3 \times 2} = 0.833$<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc</span><span class="params">(labels, preds)</span>:</span></span><br><span class="line">    n_pos = sum(labels)</span><br><span class="line">    n_neg = len(labels) - n_pos</span><br><span class="line">    labels_preds = zip(labels, preds)</span><br><span class="line">    labels_preds = sorted(labels_preds, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    rank = [label <span class="keyword">for</span> (label, pred) <span class="keyword">in</span> labels_preds]</span><br><span class="line">    rank_list = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rank)) <span class="keyword">if</span> rank[i] == <span class="number">1</span>]</span><br><span class="line">    auc = (sum(rank_list) - (n_pos * (n_pos + <span class="number">1</span>)) / <span class="number">2</span>) / (n_neg * n_pos)</span><br><span class="line">    <span class="keyword">return</span> auc</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;根据ROC曲线下的面积计算AUC&quot;&gt;&lt;a href=&quot;#根据ROC曲线下的面积计算AUC&quot; class=&quot;headerlink&quot; title=&quot;根据ROC曲线下的面积计算AUC&quot;&gt;&lt;/a&gt;根据ROC曲线下的面积计算AUC&lt;/h2&gt;&lt;p&gt;该方法的原理参考上一篇&lt;a 
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>分类问题的模型衡量指标</title>
    <link href="http://yoursite.com/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%A8%A1%E5%9E%8B%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/"/>
    <id>http://yoursite.com/分类问题的模型衡量指标/</id>
    <published>2019-06-02T14:00:56.000Z</published>
    <updated>2019-06-02T14:18:05.630Z</updated>
    
    <content type="html"><![CDATA[<p>分类问题的性能衡量指标</p><p>本文主要讨论二分类问题中的模型性能衡量指标。</p><h2 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h2><p>首先就是我们最熟悉的准确率。<br><strong>准确率（accuracy）：</strong> 预测正确的结果占总样本的百分比。<br>虽然准确率可以判断总的正确率，但是在样本不平衡的情况下，也有明显的缺点。以下面的例子来说明准确率的存在的问题：<br>假设我们的模型是一个癌症预测系统，输入体检信息，判断是否有癌症。假设该癌症的患病率为0.1%，如果我们的模型什么都不做直接预测的所有人都是健康的，那么我们的模型可以达到99.9%的准确率，然而我们的模型并不是一个性能很好的模型。<code>所以对于极度偏斜的数据，尤其是我们关注minority class时，准确率基本没有参考价值，并不能很好的衡量模型的好坏。</code></p><h2 id="精准率和召回率"><a href="#精准率和召回率" class="headerlink" title="精准率和召回率"></a>精准率和召回率</h2><h3 id="混淆矩阵-Confusion-Matrix"><a href="#混淆矩阵-Confusion-Matrix" class="headerlink" title="混淆矩阵 Confusion Matrix"></a>混淆矩阵 Confusion Matrix</h3><p>为了更好的定义精准率和召回率，我们先介绍<strong>混淆矩阵(confusion matrix)</strong><br>我们把如下的矩阵称为混淆矩阵<br><img src="/分类问题的模型衡量指标/confusion.png" alt="confusion"><br>矩阵的每一行代表预测值，每一行代表样本的真是标签。<br>我们用一个例子来理解混淆矩阵：<br>有一个癌症预测的任务，测试集为10000人，其中有9990个负样本，即没有患有癌症，为健康的用户，有10个正样本，患有癌症。经过模型的预测，在9990个健康用户中，其中有9978个健康用户被预测正确，剩下的12个用户被错误预测为患有癌症；在10个癌症患者中，其中有8个用户被预测正确，剩下的2个患者被错误预测为健康。根据上述数据可以得到其的混淆矩阵：<br><img src="/分类问题的模型衡量指标/1.png" alt="1"><br><strong>注意：我们一般把我们关注的类别记为正类，即Positive类</strong></p><h3 id="精准率与召回率"><a href="#精准率与召回率" class="headerlink" title="精准率与召回率"></a>精准率与召回率</h3><p><strong>精确率（Precision）：</strong> 又叫查准率计算方式如下：</p><script type="math/tex; mode=display">precision=\frac{TP}{TP+FP}</script><p>根据上述计算方式，上例中的$precision=\frac{8}{8+12}=40\%$<br><code>精准率是针对预测结果而言的，它的含义是在所有被预测为正的样本中实际为正样本的概率，意思就是在预测为正样本的结果中，我们有多少把握可以预测正确。</code><br><strong>召回率（recall）：</strong> 又叫查全率，计算方式如下：</p><script type="math/tex; mode=display">recall=\frac{TP}{TP+FN}</script><p>根据上述计算方式，上例中的$recall=\frac{8}{8+2}=80\%$<br>事实上，<code>召回率是针对原样本而言的，它的含义是在实际为正的样本中被预测为正样本的概率，假设测试集里面有100个正例，你的模型能预测覆盖到多少，如果你的模型预测到了40个正例，那你的recall就是40%。</code><br>下面这个图可以更好的理解精准率和召回率，<br><img src="/分类问题的模型衡量指标/precision%20recall.png" alt="precision recall"></p><h2 id="Precision-Recall的平衡"><a href="#Precision-Recall的平衡" class="headerlink" title="Precision-Recall的平衡"></a>Precision-Recall的平衡</h2><p>然而一般来说，precision和recall不可兼得，选择衡量指标还是要结合具体的使用场景。比如下面两个场景：<br>1、. 地震的预测<br>对于地震的预测，我们希望的是recall非常高，也就是说每次地震我们都希望预测出来。这个时候我们可以牺牲precision。情愿发出1000次警报，把10次地震都预测正确了；也不要预测100次对了8次漏了两次。<br>2. 嫌疑人定罪<br>基于不错怪一个好人的原则，对于嫌疑人的定罪我们希望是非常准确的。及时有时候放过了一些罪犯（recall低），但也是值得的。<br>以具体的模型为例：<br>我们知道在逻辑回归样本的预测概率大于0.5时，被判定为正类，否则被判定为父类，我们可以通过调整该概率阀值就可以平衡Precision和Recall，如下图所示。<br><img src="/分类问题的模型衡量指标/2.png" alt="2"><br>所以在上面的场景1中，我们为了更高的Recall，可以让概率阀值略小于0.5；在场景2中，我们为了更高的Precision，可以让概率阀值略大于0.5。</p><h3 id="P-R曲线"><a href="#P-R曲线" class="headerlink" title="P-R曲线"></a>P-R曲线</h3><p>根据模型不同的阀值，可以得到不同的Precision和对应Recall，然后以这些Precision为横坐标，Recall为纵坐标绘制出的曲线，称为Precision-Recall曲线或P-R曲线<br><img src="/分类问题的模型衡量指标/3.png" alt="3"></p><h2 id="F1-Score"><a href="#F1-Score" class="headerlink" title="F1 Score"></a>F1 Score</h2><p>上述说道precision和recall不可兼得，那么F1 score就是一个综合考虑precision和recall的指标，定义如下：<br><strong>F1 Score</strong>是精准率和召回率的调和平均值</p><script type="math/tex; mode=display">\frac{1}{F1} = \frac{1}{2}(\frac{1}{precision}+\frac{1}{recall})\\F1 = \frac{2·precision·recall}{precision+recall}</script><h2 id="ROC-曲线与AUC"><a href="#ROC-曲线与AUC" class="headerlink" title="ROC 曲线与AUC"></a>ROC 曲线与AUC</h2><h3 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h3><p><strong>ROC曲线（Receiver Operation Characteristic Curve)</strong> 描述的是TPR（True positive rate）和FPR（False positive rate）之前的关系。</p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN}\\FPR=\frac{FP}{TN+FP}</script><p><strong>注意：从TPR的计算方式可以看出，TPR就是我们前文讨论的Recall</strong><br>与P-R曲线相同，取不同的threshold可以得到不同的TPR和FPR，然后以 FPR为横坐标，TPR为纵坐标画出的曲线即为ROC曲线。<br><img src="/分类问题的模型衡量指标/4.png" alt="4"></p><h3 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h3><p><strong>AUC（Area Under Curve）</strong> 为ROC曲线下面的面积。<br>理想模型十分准确，TPR与FPR均等于1，则AUC为1。然而在真实模型中，AUC均在0.5到1之间，AUC越高，则模型分类效果越好。</p><p>参考：<br><a href="https://tracholar.github.io/machine-learning/2018/01/26/auc.html" target="_blank" rel="noopener">https://tracholar.github.io/machine-learning/2018/01/26/auc.html</a><br><a href="http://vividfree.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2015/11/20/understanding-ROC-and-AUC" target="_blank" rel="noopener">http://vividfree.github.io/机器学习/2015/11/20/understanding-ROC-and-AUC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分类问题的性能衡量指标&lt;/p&gt;
&lt;p&gt;本文主要讨论二分类问题中的模型性能衡量指标。&lt;/p&gt;
&lt;h2 id=&quot;准确率&quot;&gt;&lt;a href=&quot;#准确率&quot; class=&quot;headerlink&quot; title=&quot;准确率&quot;&gt;&lt;/a&gt;准确率&lt;/h2&gt;&lt;p&gt;首先就是我们最熟悉的准确率。&lt;br
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
