<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 排序基础 · 菜鸡Gustee的挣扎</title><meta name="description" content="排序基础 - Gustee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="菜鸡Gustee的挣扎"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/gustee" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">排序基础</h1><div class="post-info">Jun 2, 2019</div><div class="post-content"><p>本文主要讨论基于数组的基础排序算法，包括冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序。</p>
<p>为了代码的可读性，定义交换数组中交换两个位置的元素的工具函数（虽然用python写起来也非常方便）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    array[l], array[r] = array[r], array[l]</span><br></pre></td></tr></table></figure></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h3><p>为数组<code>[6, 3, 5, 7, 0, 4, 1, 2]</code>排序为例。首先排序的范围是<code>[0, n-1]</code>，如果前面的数比后面的数大，则交换位置，直到最大的数位于数组的最后；然后第二轮排序的范围变为<code>[0, n-2]</code>，第二轮结束后，数组第二大的数会放置在数组的倒数第二个位置；依次进行这样的排序过程，直到待排序的范围变成数组的第一个数，此时整个数组的排序完成，数组变的有序。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                swap(arr, i, j)</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(n^2)$<br><strong>空间复杂度：</strong> $O(1)$</p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="排序过程-1"><a href="#排序过程-1" class="headerlink" title="排序过程"></a>排序过程</h3><p>同样以数组<code>[6, 3, 5, 7, 0, 4, 1, 2]</code>为例。首先在数组<code>[0, n-1]</code>范围上选出一个最小值放在数组0位置；然后在数组<code>[1, n-1]</code>范围上选出一个最小值放在数组1位置；直到最后待排序范围只剩下数组最后一个数时，此时整个数组的排序完成，数组变的有序。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    min_index = <span class="number">0</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        swap(arr, i, min_index)</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(n^2)$<br><strong>空间复杂度：</strong> $O(1)$</p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="排序过程-2"><a href="#排序过程-2" class="headerlink" title="排序过程"></a>排序过程</h3><p>同样以数组<code>[6, 3, 5, 7, 0, 4, 1, 2]</code>为例。首先位置1上的数和位置0上的数进行比较，如果位置1上的数更小，则和位置0上的数交换；接下来考察位置2上面的数，如果位置2上的数比位置1小，则交换，然后继续和位置0上的数比较。假设当前考察的是数组第k个元素m，首先比较位置k-1上的数和m的大小，若大于m则交换，继续将m和位置k-2上的数比较，直到位置k-x上的数，小于等于m；直到考察完数组中所有的元素。<br><strong>note:</strong> 假如当前考察位置k上的元素，则位置<code>[0,k-1]</code>上的数一定是有序的。所以每一轮的排序实质是将当前数插入到该位置之前的有序数组中，使得增加该数后数组仍热有序。</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> arr[j] &lt; arr[j<span class="number">-1</span>]:</span><br><span class="line">            swap(arr, j, j - <span class="number">1</span>)</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(n^2)$<br><strong>空间复杂度：</strong> $O(1)$</p>
<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="排序过程-3"><a href="#排序过程-3" class="headerlink" title="排序过程"></a>排序过程</h3><p>以数组<code>[6, 5, 2, 1, 4, 3, 8, 7]</code>为例。首先让数组中的每一个数单独成为长度为1的有序区间。然后把相邻的长度为1的有序区间进行合并，得到最大长度为2的有序区间。接下来再把相邻有序区间进行合并，得到最大长度为4的有序区间。依次这样进行下去，直到两个长度为<code>n/2</code>的有序区间合并成为长度为<code>n</code>的有序区间，此时整个数组有序。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数组arr的[l, m]和[m+1, r]已经有序，合并两个区间，使其[l, r]范围有序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arr, l, m, r)</span>:</span></span><br><span class="line">        temp = []</span><br><span class="line">        p1 = l</span><br><span class="line">        p2 = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> arr[p1] &lt;= arr[p2]:</span><br><span class="line">                temp.append(arr[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.append(arr[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">        <span class="comment"># p1和p2必有且只有越界</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">            temp.append(arr[p1])</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">            temp.append(arr[p2])</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">            arr[l+i] = temp[i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r: <span class="comment"># 范围内只有一个数</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        merge_sort(arr, l, mid)</span><br><span class="line">        merge_sort(arr, mid+<span class="number">1</span>, r)</span><br><span class="line">        merge(arr, l, mid, r)</span><br><span class="line">    n = len(arr)</span><br><span class="line">    merge_sort(arr, <span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(nlog(n))$<br><strong>空间复杂度：</strong> $O(n)$</p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="排序过程-4"><a href="#排序过程-4" class="headerlink" title="排序过程"></a>排序过程</h3><p>随机在数组中选择一个数，然后让小于等于该数的元素放在该数的左边，大于这个该数的元素放在该数的右边，接下来对该数左右两边的数分别递归的调用上述排序过程，直到整个数组都有序。关于数组划分的方法可以参考<a href="https://gustee.github.io/2019/06/02/数组划分/" target="_blank" rel="noopener">另一篇文章</a></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">        pivot = arr[r]</span><br><span class="line">        small = l - <span class="number">1</span></span><br><span class="line">        big = r + <span class="number">1</span></span><br><span class="line">        cur = l</span><br><span class="line">        <span class="keyword">while</span> cur != big:</span><br><span class="line">            <span class="keyword">if</span> arr[cur] &lt; pivot:</span><br><span class="line">                small += <span class="number">1</span></span><br><span class="line">                swap(arr, cur, small)</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[cur] &gt; pivot:</span><br><span class="line">                big -= <span class="number">1</span></span><br><span class="line">                swap(arr, cur, big)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> small + <span class="number">1</span>, big - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &lt; r:</span><br><span class="line">            ll, rr = partition(arr, l, r)</span><br><span class="line">            quick_sort(arr, l, ll<span class="number">-1</span>)</span><br><span class="line">            quick_sort(arr, rr+<span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line">    quick_sort(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(nlog(n))$<br><strong>空间复杂度：</strong> $O(log(n))$~$O(n)$<code>取决于划分的具体情况</code></p>
<hr>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>概念：</strong> 堆通常是一个可以被看做一棵完全二叉树的数组对象。堆总是满足下列性质：</p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
<p>其中若某个节点的值总是不大于其父节点的值，这样的堆称为大根堆，反之称为小根堆<br>因为堆的存储结构通常是数组，所以可以通过数组的索引表示二叉树节点间的关系</p>
<ul>
<li><code>array[i]</code>的左孩子节点为<code>array[2*i+1]</code>，右孩子节点为<code>array[2*i+2]</code></li>
<li><code>array[i]</code>的父节点为<code>array[(i-1)/2]</code></li>
</ul>
<h3 id="堆的构建"><a href="#堆的构建" class="headerlink" title="堆的构建"></a>堆的构建</h3><p>假设数组<code>[0, i-1]</code>范围的元素已经构成大根堆，将<code>i</code>位置的元素加入到大根堆。若<code>i</code>位置的数比其父节点的数大，则与其父节点交换位置，然后继续与其新的父节点比较，直到该元素小于其父节点为止，此时，数组<code>i</code>位置的元素成功插入大根堆，大根堆的范围变为<code>[0, i]</code>。<br>参考代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将arr[i]插入到大根堆，使数组[0, i]范围构成大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(arr, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> arr[i] &gt; arr[int((i<span class="number">-1</span>)/<span class="number">2</span>)]:</span><br><span class="line">            swap(arr, i, int((i<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">            i = int((i<span class="number">-1</span>)/<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="堆的调整"><a href="#堆的调整" class="headerlink" title="堆的调整"></a>堆的调整</h3><p>假设数组<code>[0, size]</code>范围的元素已经构成大根堆，假设数组<code>index</code>位置的值发生改变，调整堆结构，使其重新构成大根堆。假设该节点存在左孩子，且同时存在右孩子，则取左右孩子的最大值，与该节点的值比较，若该节点的值大于最大的孩子节点，则不用调整，否则与较大的孩子交换位置，然后继续与新的孩子节点的值比较大小，判断是否需要继续下沉，直到该节点大于所有的孩子节点，重新调成为堆结构。<br>参考代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, index, size)</span>:</span></span><br><span class="line">    <span class="comment"># 左孩子的索引</span></span><br><span class="line">    left =  <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; size:</span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若右孩子存在，返回两个孩子中较大的索引，否则返回左孩子索引</span></span><br><span class="line">        max_children = right <span class="keyword">if</span> (right&lt;size <span class="keyword">and</span> arr[right]&gt;arr[left]) <span class="keyword">else</span> left</span><br><span class="line">        <span class="comment"># 若当前节点的值大于孩子中的最大值，则不需要调整，否则交换</span></span><br><span class="line">        <span class="keyword">if</span> arr[index] &gt; arr[max_children]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        swap(arr, index, max_children)</span><br><span class="line">        <span class="comment"># 更新该值的新索引，以进一步判断是否需要继续调整</span></span><br><span class="line">        index = max_children</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="排序过程-5"><a href="#排序过程-5" class="headerlink" title="排序过程"></a>排序过程</h3><p>首先将数组中的n个数构造成为一个大根堆，我们知道堆顶是所有元素的最大值，我们将堆顶元素和堆的最后一个元素进行交换，然后把最大值脱离整个堆结构，放在数组的最后的位置，作为数组的有序部分保存下来；接下来重新将数组<code>[0, n-2]</code>范围的n-1个数重新调整为大根堆，然后将新堆顶元素和堆的最后一个元素进行交换，然后把最大值脱离整个堆结构，放在数组的倒数第二的位置，作为数组的有序部分保存下来。这样每次从堆顶弹出一个元素，堆的大小也依次减1，当堆的大小减为1时，整个数组有序。</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(arr, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> arr[i] &gt; arr[int((i<span class="number">-1</span>)/<span class="number">2</span>)]:</span><br><span class="line">            swap(arr, i, int((i<span class="number">-1</span>)/<span class="number">2</span>))</span><br><span class="line">            i = int((i<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, index, size)</span>:</span></span><br><span class="line">        left =  <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; size:</span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line">            max_children = right <span class="keyword">if</span> (right&lt;size <span class="keyword">and</span> arr[right]&gt;arr[left]) <span class="keyword">else</span> left</span><br><span class="line">            <span class="keyword">if</span> arr[index] &gt; arr[max_children]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            swap(arr, index, max_children)</span><br><span class="line">            index = max_children</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        insert(arr, i)</span><br><span class="line">    heap_size = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> heap_size &gt; <span class="number">0</span>:</span><br><span class="line">        heap_size -= <span class="number">1</span>  <span class="comment"># 从堆顶弹出一个元素，堆大小减一</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, heap_size) <span class="comment"># 将元素放置堆外作为数组的有序部分</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heap_size)  <span class="comment"># 堆顶元素变化，重新调整堆结构</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> $O(nlog(n))$<br><strong>空间复杂度：</strong> $O(1)$</p>
<h2 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h2><p><strong>概念：</strong> 假定待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，称这种排序算法是稳定的，否则称为不稳定的。</p>
<p>稳定：冒泡排序  插入排序  归并排序<br>不稳定：选择排序 快速排序 堆排序</p>
</div></article></div></main><footer><div class="paginator"><a href="/算法之排列组合问题/" class="prev">上一篇</a><a href="/数组划分/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Gustee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>